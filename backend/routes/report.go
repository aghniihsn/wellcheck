package routes

import (
	"backend/models"
	"context"
	"net/http"
	"os"
	"time"

	"bytes"
	"encoding/csv"
	"strconv"

	"github.com/gofiber/fiber/v2"
	"github.com/golang-jwt/jwt/v5"
	"github.com/jung-kurt/gofpdf"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
)

func RegisterReportRoutes(app *fiber.App, db *mongo.Database) {
	// Deklarasi JWT dan authRequired di awal
	jwtSecret := []byte(os.Getenv("JWT_SECRET"))
	authRequired := func(c *fiber.Ctx) error {
		tokenStr := c.Get("Authorization")
		if tokenStr == "" || len(tokenStr) < 8 {
			return c.Status(http.StatusUnauthorized).JSON(fiber.Map{"error": "Missing or invalid token"})
		}
		tokenStr = tokenStr[7:]
		token, err := jwt.ParseWithClaims(tokenStr, jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) {
			return jwtSecret, nil
		})
		if err != nil || !token.Valid {
			return c.Status(http.StatusUnauthorized).JSON(fiber.Map{"error": "Invalid token"})
		}
		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			return c.Status(http.StatusUnauthorized).JSON(fiber.Map{"error": "Invalid token claims"})
		}
		c.Locals("userId", claims["id"])
		c.Locals("userRole", claims["role"])
		return c.Next()
	}

	reportGroup := app.Group("/api/reports", authRequired)

	// Endpoint generate report (POST /reports/generate) - langsung download PDF
	reportGroup.Post("/generate", func(c *fiber.Ctx) error {
		var req map[string]interface{}
		if err := c.BodyParser(&req); err != nil {
			return c.Status(http.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request"})
		}
		// Ambil data dari form frontend
		title, _ := req["title"].(string)
		teamId, _ := req["teamId"].(string)
		createdBy := c.Locals("userId")
		// Generate PDF dummy (bisa diganti dengan isi report sebenarnya)
		pdf := gofpdf.New("P", "mm", "A4", "")
		pdf.AddPage()
		pdf.SetFont("Arial", "B", 16)
		pdf.Cell(40, 10, "Report Title: "+title)
		pdf.Ln(12)
		pdf.SetFont("Arial", "", 12)
		pdf.Cell(40, 10, "Team ID: "+teamId)
		pdf.Ln(10)
		pdf.Cell(40, 10, "Generated by: "+createdBy.(string))
		pdf.Ln(10)
		pdf.Cell(40, 10, "Generated at: "+time.Now().Format("2006-01-02 15:04:05"))
		// ...tambahkan isi report sesuai kebutuhan...
		// Output PDF ke buffer
		var buf bytes.Buffer
		err := pdf.Output(&buf)
		if err != nil {
			return c.Status(http.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to generate PDF"})
		}
		c.Set("Content-Type", "application/pdf")
		c.Set("Content-Disposition", "attachment;filename=report.pdf")
		return c.SendStream(&buf)
	})

	// Endpoint download report sebagai CSV
	reportGroup.Get("/:id/download", func(c *fiber.Ctx) error {
		reportID := c.Params("id")
		var report models.Report
		err := db.Collection("reports").FindOne(context.Background(), bson.M{"id": reportID}).Decode(&report)
		if err != nil {
			return c.Status(http.StatusNotFound).JSON(fiber.Map{"error": "Report not found"})
		}
		summary, ok := report.Data.(map[string]interface{})
		if !ok {
			return c.Status(http.StatusInternalServerError).JSON(fiber.Map{"error": "Invalid report data"})
		}
		var moodCount map[string]int
		if raw, ok := summary["moodCount"]; ok {
			switch v := raw.(type) {
			case map[string]int:
				moodCount = v
			case map[string]interface{}:
				moodCount = map[string]int{}
				for k, val := range v {
					switch vv := val.(type) {
					case int:
						moodCount[k] = vv
					case int32:
						moodCount[k] = int(vv)
					case int64:
						moodCount[k] = int(vv)
					case float64:
						moodCount[k] = int(vv)
					}
				}
			}
		}
		c.Set("Content-Type", "text/csv")
		c.Set("Content-Disposition", "attachment;filename=report_"+reportID+".csv")
		writer := csv.NewWriter(c)
		writer.Write([]string{"Mood", "Count"})
		for mood, count := range moodCount {
			writer.Write([]string{mood, strconv.Itoa(count)})
		}
		writer.Flush()
		return nil
	})

	// Endpoint untuk mengambil semua report (list)
	reportGroup.Get("/", func(c *fiber.Ctx) error {
		var reports []models.Report
		cursor, err := db.Collection("reports").Find(context.Background(), bson.M{})
		if err != nil {
			return c.Status(http.StatusInternalServerError).JSON(fiber.Map{"error": "Failed to fetch reports"})
		}
		defer cursor.Close(context.Background())
		for cursor.Next(context.Background()) {
			var report models.Report
			if err := cursor.Decode(&report); err == nil {
				reports = append(reports, report)
			}
		}
		return c.JSON(reports)
	})
}
